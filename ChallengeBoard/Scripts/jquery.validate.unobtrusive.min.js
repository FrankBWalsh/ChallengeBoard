/*
** Unobtrusive validation support library for jQuery and jQuery Validate
** Copyright (C) Microsoft Corporation. All rights reserved.
*/
(function (e) { function i(e, t, n) { e.rules[t] = n; if (e.message) { e.messages[t] = e.message } } function s(e) { return e.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g) } function o(e) { return e.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g, "\\$1") } function u(e) { return e.substr(0, e.lastIndexOf(".") + 1) } function a(e, t) { if (e.indexOf("*.") === 0) { e = e.replace("*.", t) } return e } function f(t, n) { var r = e(this).find("[data-valmsg-for='" + o(n[0].name) + "']"), i = r.attr("data-valmsg-replace"), s = i ? e.parseJSON(i) !== false : null; r.removeClass("field-validation-valid").addClass("field-validation-error"); t.data("unobtrusiveContainer", r); if (s) { r.empty(); t.removeClass("input-validation-error").appendTo(r) } else { t.hide() } } function l(t, n) { var r = e(this).find("[data-valmsg-summary=true]"), i = r.find("ul"); if (i && i.length && n.errorList.length) { i.empty(); r.addClass("validation-summary-errors").removeClass("validation-summary-valid"); e.each(n.errorList, function () { e("<li />").html(this.message).appendTo(i) }) } } function c(t) { var n = t.data("unobtrusiveContainer"), r = n.attr("data-valmsg-replace"), i = r ? e.parseJSON(r) : null; if (n) { n.addClass("field-validation-valid").removeClass("field-validation-error"); t.removeData("unobtrusiveContainer"); if (i) { n.empty() } } } function h(t) { var n = e(this); n.data("validator").resetForm(); n.find(".validation-summary-errors").addClass("validation-summary-valid").removeClass("validation-summary-errors"); n.find(".field-validation-error").addClass("field-validation-valid").removeClass("field-validation-error").removeData("unobtrusiveContainer").find(">*").removeData("unobtrusiveContainer") } function p(t) { var n = e(t), i = n.data(r), s = e.proxy(h, t); if (!i) { i = { options: { errorClass: "input-validation-error", errorElement: "span", errorPlacement: e.proxy(f, t), invalidHandler: e.proxy(l, t), messages: {}, rules: {}, success: e.proxy(c, t) }, attachValidation: function () { n.unbind("reset." + r, s).bind("reset." + r, s).validate(this.options) }, validate: function () { n.validate(); return n.valid() } }; n.data(r, i) } return i } var t = e.validator, n, r = "unobtrusiveValidation"; t.unobtrusive = { adapters: [], parseElement: function (t, n) { var r = e(t), i = r.parents("form")[0], s, o, u; if (!i) { return } s = p(i); s.options.rules[t.name] = o = {}; s.options.messages[t.name] = u = {}; e.each(this.adapters, function () { var n = "data-val-" + this.name, s = r.attr(n), a = {}; if (s !== undefined) { n += "-"; e.each(this.params, function () { a[this] = r.attr(n + this) }); this.adapt({ element: t, form: i, message: s, params: a, rules: o, messages: u }) } }); e.extend(o, { __dummy__: true }); if (!n) { s.attachValidation() } }, parse: function (n) { var r = e(n).parents("form").andSelf().add(e(n).find("form")).filter("form"); e(n).find(":input[data-val=true]").each(function () { t.unobtrusive.parseElement(this, true) }); r.each(function () { var e = p(this); if (e) { e.attachValidation() } }) } }; n = t.unobtrusive.adapters; n.add = function (e, t, n) { if (!n) { n = t; t = [] } this.push({ name: e, params: t, adapt: n }); return this }; n.addBool = function (e, t) { return this.add(e, function (n) { i(n, t || e, true) }) }; n.addMinMax = function (e, t, n, r, s, o) { return this.add(e, [s || "min", o || "max"], function (e) { var s = e.params.min, o = e.params.max; if (s && o) { i(e, r, [s, o]) } else if (s) { i(e, t, s) } else if (o) { i(e, n, o) } }) }; n.addSingleVal = function (e, t, n) { return this.add(e, [t || "val"], function (r) { i(r, n || e, r.params[t]) }) }; t.addMethod("__dummy__", function (e, t, n) { return true }); t.addMethod("regex", function (e, t, n) { var r; if (this.optional(t)) { return true } r = (new RegExp(n)).exec(e); return r && r.index === 0 && r[0].length === e.length }); t.addMethod("nonalphamin", function (e, t, n) { var r; if (n) { r = e.match(/\W/g); r = r && r.length >= n } return r }); n.addSingleVal("accept", "exts").addSingleVal("regex", "pattern"); n.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url"); n.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range"); n.add("equalto", ["other"], function (t) { var n = u(t.element.name), r = t.params.other, s = a(r, n), f = e(t.form).find(":input[name='" + o(s) + "']")[0]; i(t, "equalTo", f) }); n.add("required", function (e) { if (e.element.tagName.toUpperCase() !== "INPUT" || e.element.type.toUpperCase() !== "CHECKBOX") { i(e, "required", true) } }); n.add("remote", ["url", "type", "additionalfields"], function (t) { var n = { url: t.params.url, type: t.params.type || "GET", data: {} }, r = u(t.element.name); e.each(s(t.params.additionalfields || t.element.name), function (i, s) { var u = a(s, r); n.data[u] = function () { return e(t.form).find(":input[name='" + o(u) + "']").val() } }); i(t, "remote", n) }); n.add("password", ["min", "nonalphamin", "regex"], function (e) { if (e.params.min) { i(e, "minlength", e.params.min) } if (e.params.nonalphamin) { i(e, "nonalphamin", e.params.nonalphamin) } if (e.params.regex) { i(e, "regex", e.params.regex) } }); e(function () { t.unobtrusive.parse(document) }) })(jQuery)